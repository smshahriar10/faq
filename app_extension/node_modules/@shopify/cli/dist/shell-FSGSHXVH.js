import {
  require_glob
} from "./chunk-3CU2FNWB.js";
import "./chunk-6MJ52OLD.js";
import "./chunk-F6GZ5SSL.js";
import {
  __commonJS,
  __esm,
  __glob,
  __require,
  init_cjs_shims
} from "./chunk-BVGYIZ3O.js";

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/common.js"(exports) {
    "use strict";
    init_cjs_shims();
    var os = __require("os");
    var fs = __require("fs");
    var glob = require_glob();
    var shell = require_shell();
    var shellMethods = Object.create(shell);
    exports.extend = Object.assign;
    var isElectron = Boolean(process.versions.electron);
    var DEFAULT_CONFIG = {
      fatal: false,
      globOptions: {},
      maxdepth: 255,
      noglob: false,
      silent: false,
      verbose: false,
      execPath: null,
      bufLength: 64 * 1024
      // 64KB
    };
    var config = {
      reset: function() {
        Object.assign(this, DEFAULT_CONFIG);
        if (!isElectron) {
          this.execPath = process.execPath;
        }
      },
      resetForTesting: function() {
        this.reset();
        this.silent = true;
      }
    };
    config.reset();
    exports.config = config;
    var state = {
      error: null,
      errorCode: 0,
      currentCmd: "shell.js"
    };
    exports.state = state;
    delete process.env.OLDPWD;
    function isObject(a) {
      return typeof a === "object" && a !== null;
    }
    exports.isObject = isObject;
    function log() {
      if (!config.silent) {
        console.error.apply(console, arguments);
      }
    }
    exports.log = log;
    function convertErrorOutput(msg) {
      if (typeof msg !== "string") {
        throw new TypeError("input must be a string");
      }
      return msg.replace(/\\/g, "/");
    }
    exports.convertErrorOutput = convertErrorOutput;
    function error(msg, _code, options) {
      if (typeof msg !== "string")
        throw new Error("msg must be a string");
      var DEFAULT_OPTIONS = {
        continue: false,
        code: 1,
        prefix: state.currentCmd + ": ",
        silent: false
      };
      if (typeof _code === "number" && isObject(options)) {
        options.code = _code;
      } else if (isObject(_code)) {
        options = _code;
      } else if (typeof _code === "number") {
        options = { code: _code };
      } else if (typeof _code !== "number") {
        options = {};
      }
      options = Object.assign({}, DEFAULT_OPTIONS, options);
      if (!state.errorCode)
        state.errorCode = options.code;
      var logEntry = convertErrorOutput(options.prefix + msg);
      state.error = state.error ? state.error + "\n" : "";
      state.error += logEntry;
      if (config.fatal)
        throw new Error(logEntry);
      if (msg.length > 0 && !options.silent)
        log(logEntry);
      if (!options.continue) {
        throw {
          msg: "earlyExit",
          retValue: new ShellString("", state.error, state.errorCode)
        };
      }
    }
    exports.error = error;
    function ShellString(stdout, stderr, code) {
      var that;
      if (stdout instanceof Array) {
        that = stdout;
        that.stdout = stdout.join("\n");
        if (stdout.length > 0)
          that.stdout += "\n";
      } else {
        that = new String(stdout);
        that.stdout = stdout;
      }
      that.stderr = stderr;
      that.code = code;
      pipeMethods.forEach(function(cmd) {
        that[cmd] = shellMethods[cmd].bind(that);
      });
      return that;
    }
    exports.ShellString = ShellString;
    function parseOptions(opt, map, errorOptions) {
      if (typeof opt !== "string" && !isObject(opt)) {
        throw new Error("options must be strings or key-value pairs");
      } else if (!isObject(map)) {
        throw new Error("parseOptions() internal error: map must be an object");
      } else if (errorOptions && !isObject(errorOptions)) {
        throw new Error("parseOptions() internal error: errorOptions must be object");
      }
      if (opt === "--") {
        return {};
      }
      var options = {};
      Object.keys(map).forEach(function(letter) {
        var optName = map[letter];
        if (optName[0] !== "!") {
          options[optName] = false;
        }
      });
      if (opt === "")
        return options;
      if (typeof opt === "string") {
        if (opt[0] !== "-") {
          throw new Error("Options string must start with a '-'");
        }
        var chars = opt.slice(1).split("");
        chars.forEach(function(c) {
          if (c in map) {
            var optionName = map[c];
            if (optionName[0] === "!") {
              options[optionName.slice(1)] = false;
            } else {
              options[optionName] = true;
            }
          } else {
            error("option not recognized: " + c, errorOptions || {});
          }
        });
      } else {
        Object.keys(opt).forEach(function(key) {
          var c = key[1];
          if (c in map) {
            var optionName = map[c];
            options[optionName] = opt[key];
          } else {
            error("option not recognized: " + c, errorOptions || {});
          }
        });
      }
      return options;
    }
    exports.parseOptions = parseOptions;
    function expand(list) {
      if (!Array.isArray(list)) {
        throw new TypeError("must be an array");
      }
      var expanded = [];
      list.forEach(function(listEl) {
        if (typeof listEl !== "string") {
          expanded.push(listEl);
        } else {
          var ret;
          try {
            ret = glob.sync(listEl, config.globOptions);
            ret = ret.length > 0 ? ret : [listEl];
          } catch (e) {
            ret = [listEl];
          }
          expanded = expanded.concat(ret);
        }
      });
      return expanded;
    }
    exports.expand = expand;
    var buffer = typeof Buffer.alloc === "function" ? function(len) {
      return Buffer.alloc(len || config.bufLength);
    } : function(len) {
      return new Buffer(len || config.bufLength);
    };
    exports.buffer = buffer;
    function unlinkSync(file) {
      try {
        fs.unlinkSync(file);
      } catch (e) {
        if (e.code === "EPERM") {
          fs.chmodSync(file, "0666");
          fs.unlinkSync(file);
        } else {
          throw e;
        }
      }
    }
    exports.unlinkSync = unlinkSync;
    function statFollowLinks() {
      return fs.statSync.apply(fs, arguments);
    }
    exports.statFollowLinks = statFollowLinks;
    function statNoFollowLinks() {
      return fs.lstatSync.apply(fs, arguments);
    }
    exports.statNoFollowLinks = statNoFollowLinks;
    function randomFileName() {
      function randomHash(count) {
        if (count === 1) {
          return parseInt(16 * Math.random(), 10).toString(16);
        }
        var hash = "";
        for (var i = 0; i < count; i++) {
          hash += randomHash(1);
        }
        return hash;
      }
      return "shelljs_" + randomHash(20);
    }
    exports.randomFileName = randomFileName;
    function wrap(cmd, fn, options) {
      options = options || {};
      return function() {
        var retValue = null;
        state.currentCmd = cmd;
        state.error = null;
        state.errorCode = 0;
        try {
          var args = [].slice.call(arguments, 0);
          if (config.verbose) {
            console.error.apply(console, [cmd].concat(args));
          }
          state.pipedValue = this && typeof this.stdout === "string" ? this.stdout : "";
          if (options.unix === false) {
            retValue = fn.apply(this, args);
          } else {
            if (isObject(args[0]) && args[0].constructor.name === "Object") {
            } else if (args.length === 0 || typeof args[0] !== "string" || args[0].length <= 1 || args[0][0] !== "-") {
              args.unshift("");
            }
            args = args.reduce(function(accum, cur) {
              if (Array.isArray(cur)) {
                return accum.concat(cur);
              }
              accum.push(cur);
              return accum;
            }, []);
            args = args.map(function(arg) {
              if (isObject(arg) && arg.constructor.name === "String") {
                return arg.toString();
              }
              return arg;
            });
            var homeDir = os.homedir();
            args = args.map(function(arg) {
              if (typeof arg === "string" && arg.slice(0, 2) === "~/" || arg === "~") {
                return arg.replace(/^~/, homeDir);
              }
              return arg;
            });
            if (!config.noglob && options.allowGlobbing === true) {
              args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));
            }
            try {
              if (isObject(options.cmdOptions)) {
                args[0] = parseOptions(args[0], options.cmdOptions);
              }
              retValue = fn.apply(this, args);
            } catch (e) {
              if (e.msg === "earlyExit") {
                retValue = e.retValue;
              } else {
                throw e;
              }
            }
          }
        } catch (e) {
          if (!state.error) {
            e.name = "ShellJSInternalError";
            throw e;
          }
          if (config.fatal)
            throw e;
        }
        if (options.wrapOutput && (typeof retValue === "string" || Array.isArray(retValue))) {
          retValue = new ShellString(retValue, state.error, state.errorCode);
        }
        state.currentCmd = "shell.js";
        return retValue;
      };
    }
    exports.wrap = wrap;
    function _readFromPipe() {
      return state.pipedValue;
    }
    exports.readFromPipe = _readFromPipe;
    var DEFAULT_WRAP_OPTIONS = {
      allowGlobbing: true,
      canReceivePipe: false,
      cmdOptions: null,
      globStart: 1,
      pipeOnly: false,
      wrapOutput: true,
      unix: true
    };
    var pipeMethods = [];
    function _register(name, implementation, wrapOptions) {
      wrapOptions = wrapOptions || {};
      Object.keys(wrapOptions).forEach(function(option) {
        if (!DEFAULT_WRAP_OPTIONS.hasOwnProperty(option)) {
          throw new Error("Unknown option '" + option + "'");
        }
        if (typeof wrapOptions[option] !== typeof DEFAULT_WRAP_OPTIONS[option]) {
          throw new TypeError("Unsupported type '" + typeof wrapOptions[option] + "' for option '" + option + "'");
        }
      });
      wrapOptions = Object.assign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);
      if (shell.hasOwnProperty(name)) {
        throw new Error("Command `" + name + "` already exists");
      }
      if (wrapOptions.pipeOnly) {
        wrapOptions.canReceivePipe = true;
        shellMethods[name] = wrap(name, implementation, wrapOptions);
      } else {
        shell[name] = wrap(name, implementation, wrapOptions);
      }
      if (wrapOptions.canReceivePipe) {
        pipeMethods.push(name);
      }
    }
    exports.register = _register;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/cat.js
var require_cat = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/cat.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("cat", _cat, {
      canReceivePipe: true,
      cmdOptions: {
        "n": "number"
      }
    });
    function _cat(options, files) {
      var cat = common.readFromPipe();
      if (!files && !cat)
        common.error("no paths given");
      files = [].slice.call(arguments, 1);
      files.forEach(function(file) {
        if (!fs.existsSync(file)) {
          common.error("no such file or directory: " + file);
        } else if (common.statFollowLinks(file).isDirectory()) {
          common.error(file + ": Is a directory");
        }
        cat += fs.readFileSync(file, "utf8");
      });
      if (options.number) {
        cat = addNumbers(cat);
      }
      return cat;
    }
    module.exports = _cat;
    function addNumbers(cat) {
      var lines = cat.split("\n");
      var lastLine = lines.pop();
      lines = lines.map(function(line, i) {
        return numberedLine(i + 1, line);
      });
      if (lastLine.length) {
        lastLine = numberedLine(lines.length + 1, lastLine);
      }
      lines.push(lastLine);
      return lines.join("\n");
    }
    function numberedLine(n, line) {
      var number = ("     " + n).slice(-6) + "	";
      return number + line;
    }
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/cd.js
var require_cd = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/cd.js"(exports, module) {
    init_cjs_shims();
    var os = __require("os");
    var common = require_common();
    common.register("cd", _cd, {});
    function _cd(options, dir) {
      if (!dir)
        dir = os.homedir();
      if (dir === "-") {
        if (!process.env.OLDPWD) {
          common.error("could not find previous directory");
        } else {
          dir = process.env.OLDPWD;
        }
      }
      try {
        var curDir = process.cwd();
        process.chdir(dir);
        process.env.OLDPWD = curDir;
      } catch (e) {
        var err;
        try {
          common.statFollowLinks(dir);
          err = "not a directory: " + dir;
        } catch (e2) {
          err = "no such file or directory: " + dir;
        }
        if (err)
          common.error(err);
      }
      return "";
    }
    module.exports = _cd;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/chmod.js
var require_chmod = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/chmod.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    var path = __require("path");
    var PERMS = function(base) {
      return {
        OTHER_EXEC: base.EXEC,
        OTHER_WRITE: base.WRITE,
        OTHER_READ: base.READ,
        GROUP_EXEC: base.EXEC << 3,
        GROUP_WRITE: base.WRITE << 3,
        GROUP_READ: base.READ << 3,
        OWNER_EXEC: base.EXEC << 6,
        OWNER_WRITE: base.WRITE << 6,
        OWNER_READ: base.READ << 6,
        // Literal octal numbers are apparently not allowed in "strict" javascript.
        STICKY: parseInt("01000", 8),
        SETGID: parseInt("02000", 8),
        SETUID: parseInt("04000", 8),
        TYPE_MASK: parseInt("0770000", 8)
      };
    }({
      EXEC: 1,
      WRITE: 2,
      READ: 4
    });
    common.register("chmod", _chmod, {});
    function _chmod(options, mode, filePattern) {
      if (!filePattern) {
        if (options.length > 0 && options.charAt(0) === "-") {
          [].unshift.call(arguments, "");
        } else {
          common.error("You must specify a file.");
        }
      }
      options = common.parseOptions(options, {
        "R": "recursive",
        "c": "changes",
        "v": "verbose"
      });
      filePattern = [].slice.call(arguments, 2);
      var files;
      if (options.recursive) {
        files = [];
        filePattern.forEach(function addFile(expandedFile) {
          var stat = common.statNoFollowLinks(expandedFile);
          if (!stat.isSymbolicLink()) {
            files.push(expandedFile);
            if (stat.isDirectory()) {
              fs.readdirSync(expandedFile).forEach(function(child) {
                addFile(expandedFile + "/" + child);
              });
            }
          }
        });
      } else {
        files = filePattern;
      }
      files.forEach(function innerChmod(file) {
        file = path.resolve(file);
        if (!fs.existsSync(file)) {
          common.error("File not found: " + file);
        }
        if (options.recursive && common.statNoFollowLinks(file).isSymbolicLink()) {
          return;
        }
        var stat = common.statFollowLinks(file);
        var isDir = stat.isDirectory();
        var perms = stat.mode;
        var type = perms & PERMS.TYPE_MASK;
        var newPerms = perms;
        if (isNaN(parseInt(mode, 8))) {
          mode.split(",").forEach(function(symbolicMode) {
            var pattern = /([ugoa]*)([=\+-])([rwxXst]*)/i;
            var matches = pattern.exec(symbolicMode);
            if (matches) {
              var applyTo = matches[1];
              var operator = matches[2];
              var change = matches[3];
              var changeOwner = applyTo.indexOf("u") !== -1 || applyTo === "a" || applyTo === "";
              var changeGroup = applyTo.indexOf("g") !== -1 || applyTo === "a" || applyTo === "";
              var changeOther = applyTo.indexOf("o") !== -1 || applyTo === "a" || applyTo === "";
              var changeRead = change.indexOf("r") !== -1;
              var changeWrite = change.indexOf("w") !== -1;
              var changeExec = change.indexOf("x") !== -1;
              var changeExecDir = change.indexOf("X") !== -1;
              var changeSticky = change.indexOf("t") !== -1;
              var changeSetuid = change.indexOf("s") !== -1;
              if (changeExecDir && isDir) {
                changeExec = true;
              }
              var mask = 0;
              if (changeOwner) {
                mask |= (changeRead ? PERMS.OWNER_READ : 0) + (changeWrite ? PERMS.OWNER_WRITE : 0) + (changeExec ? PERMS.OWNER_EXEC : 0) + (changeSetuid ? PERMS.SETUID : 0);
              }
              if (changeGroup) {
                mask |= (changeRead ? PERMS.GROUP_READ : 0) + (changeWrite ? PERMS.GROUP_WRITE : 0) + (changeExec ? PERMS.GROUP_EXEC : 0) + (changeSetuid ? PERMS.SETGID : 0);
              }
              if (changeOther) {
                mask |= (changeRead ? PERMS.OTHER_READ : 0) + (changeWrite ? PERMS.OTHER_WRITE : 0) + (changeExec ? PERMS.OTHER_EXEC : 0);
              }
              if (changeSticky) {
                mask |= PERMS.STICKY;
              }
              switch (operator) {
                case "+":
                  newPerms |= mask;
                  break;
                case "-":
                  newPerms &= ~mask;
                  break;
                case "=":
                  newPerms = type + mask;
                  if (common.statFollowLinks(file).isDirectory()) {
                    newPerms |= PERMS.SETUID + PERMS.SETGID & perms;
                  }
                  break;
                default:
                  common.error("Could not recognize operator: `" + operator + "`");
              }
              if (options.verbose) {
                console.log(file + " -> " + newPerms.toString(8));
              }
              if (perms !== newPerms) {
                if (!options.verbose && options.changes) {
                  console.log(file + " -> " + newPerms.toString(8));
                }
                fs.chmodSync(file, newPerms);
                perms = newPerms;
              }
            } else {
              common.error("Invalid symbolic mode change: " + symbolicMode);
            }
          });
        } else {
          newPerms = type + parseInt(mode, 8);
          if (common.statFollowLinks(file).isDirectory()) {
            newPerms |= PERMS.SETUID + PERMS.SETGID & perms;
          }
          fs.chmodSync(file, newPerms);
        }
      });
      return "";
    }
    module.exports = _chmod;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/cp.js
var require_cp = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/cp.js"(exports, module) {
    init_cjs_shims();
    var fs = __require("fs");
    var path = __require("path");
    var common = require_common();
    common.register("cp", _cp, {
      cmdOptions: {
        "f": "!no_force",
        "n": "no_force",
        "u": "update",
        "R": "recursive",
        "r": "recursive",
        "L": "followsymlink",
        "P": "noFollowsymlink"
      },
      wrapOutput: false
    });
    function copyFileSync(srcFile, destFile, options) {
      if (!fs.existsSync(srcFile)) {
        common.error("copyFileSync: no such file or directory: " + srcFile);
      }
      var isWindows = process.platform === "win32";
      try {
        if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {
          return;
        }
      } catch (e) {
      }
      if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {
        try {
          common.statNoFollowLinks(destFile);
          common.unlinkSync(destFile);
        } catch (e) {
        }
        var symlinkFull = fs.readlinkSync(srcFile);
        fs.symlinkSync(symlinkFull, destFile, isWindows ? "junction" : null);
      } else {
        var buf = common.buffer();
        var bufLength = buf.length;
        var bytesRead = bufLength;
        var pos = 0;
        var fdr = null;
        var fdw = null;
        try {
          fdr = fs.openSync(srcFile, "r");
        } catch (e) {
          common.error("copyFileSync: could not read src file (" + srcFile + ")");
        }
        try {
          fdw = fs.openSync(destFile, "w");
        } catch (e) {
          common.error("copyFileSync: could not write to dest file (code=" + e.code + "):" + destFile);
        }
        while (bytesRead === bufLength) {
          bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);
          fs.writeSync(fdw, buf, 0, bytesRead);
          pos += bytesRead;
        }
        fs.closeSync(fdr);
        fs.closeSync(fdw);
        fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);
      }
    }
    function cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {
      if (!opts)
        opts = {};
      if (currentDepth >= common.config.maxdepth)
        return;
      currentDepth++;
      var isWindows = process.platform === "win32";
      try {
        fs.mkdirSync(destDir);
      } catch (e) {
        if (e.code !== "EEXIST")
          throw e;
      }
      var files = fs.readdirSync(sourceDir);
      for (var i = 0; i < files.length; i++) {
        var srcFile = sourceDir + "/" + files[i];
        var destFile = destDir + "/" + files[i];
        var srcFileStat = common.statNoFollowLinks(srcFile);
        var symlinkFull;
        if (opts.followsymlink) {
          if (cpcheckcycle(sourceDir, srcFile)) {
            console.error("Cycle link found.");
            symlinkFull = fs.readlinkSync(srcFile);
            fs.symlinkSync(symlinkFull, destFile, isWindows ? "junction" : null);
            continue;
          }
        }
        if (srcFileStat.isDirectory()) {
          cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);
        } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {
          symlinkFull = fs.readlinkSync(srcFile);
          try {
            common.statNoFollowLinks(destFile);
            common.unlinkSync(destFile);
          } catch (e) {
          }
          fs.symlinkSync(symlinkFull, destFile, isWindows ? "junction" : null);
        } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {
          srcFileStat = common.statFollowLinks(srcFile);
          if (srcFileStat.isDirectory()) {
            cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);
          } else {
            copyFileSync(srcFile, destFile, opts);
          }
        } else {
          if (fs.existsSync(destFile) && opts.no_force) {
            common.log("skipping existing file: " + files[i]);
          } else {
            copyFileSync(srcFile, destFile, opts);
          }
        }
      }
      var checkDir = common.statFollowLinks(sourceDir);
      fs.chmodSync(destDir, checkDir.mode);
    }
    function checkRecentCreated(sources, index) {
      var lookedSource = sources[index];
      return sources.slice(0, index).some(function(src) {
        return path.basename(src) === path.basename(lookedSource);
      });
    }
    function cpcheckcycle(sourceDir, srcFile) {
      var srcFileStat = common.statNoFollowLinks(srcFile);
      if (srcFileStat.isSymbolicLink()) {
        var cyclecheck = common.statFollowLinks(srcFile);
        if (cyclecheck.isDirectory()) {
          var sourcerealpath = fs.realpathSync(sourceDir);
          var symlinkrealpath = fs.realpathSync(srcFile);
          var re = new RegExp(symlinkrealpath);
          if (re.test(sourcerealpath)) {
            return true;
          }
        }
      }
      return false;
    }
    function _cp(options, sources, dest) {
      if (options.followsymlink) {
        options.noFollowsymlink = false;
      }
      if (!options.recursive && !options.noFollowsymlink) {
        options.followsymlink = true;
      }
      if (arguments.length < 3) {
        common.error("missing <source> and/or <dest>");
      } else {
        sources = [].slice.call(arguments, 1, arguments.length - 1);
        dest = arguments[arguments.length - 1];
      }
      var destExists = fs.existsSync(dest);
      var destStat = destExists && common.statFollowLinks(dest);
      if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {
        common.error("dest is not a directory (too many sources)");
      }
      if (destExists && destStat.isFile() && options.no_force) {
        return new common.ShellString("", "", 0);
      }
      sources.forEach(function(src, srcIndex) {
        if (!fs.existsSync(src)) {
          if (src === "")
            src = "''";
          common.error("no such file or directory: " + src, { continue: true });
          return;
        }
        var srcStat = common.statFollowLinks(src);
        if (!options.noFollowsymlink && srcStat.isDirectory()) {
          if (!options.recursive) {
            common.error("omitting directory '" + src + "'", { continue: true });
          } else {
            var newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(src)) : dest;
            try {
              common.statFollowLinks(path.dirname(dest));
              cpdirSyncRecursive(src, newDest, 0, { no_force: options.no_force, followsymlink: options.followsymlink });
            } catch (e) {
              common.error("cannot create directory '" + dest + "': No such file or directory");
            }
          }
        } else {
          var thisDest = dest;
          if (destStat && destStat.isDirectory()) {
            thisDest = path.normalize(dest + "/" + path.basename(src));
          }
          var thisDestExists = fs.existsSync(thisDest);
          if (thisDestExists && checkRecentCreated(sources, srcIndex)) {
            if (!options.no_force) {
              common.error("will not overwrite just-created '" + thisDest + "' with '" + src + "'", { continue: true });
            }
            return;
          }
          if (thisDestExists && options.no_force) {
            return;
          }
          if (path.relative(src, thisDest) === "") {
            common.error("'" + thisDest + "' and '" + src + "' are the same file", { continue: true });
            return;
          }
          copyFileSync(src, thisDest, options);
        }
      });
      return new common.ShellString("", common.state.error, common.state.errorCode);
    }
    module.exports = _cp;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/dirs.js
var require_dirs = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/dirs.js"(exports) {
    init_cjs_shims();
    var common = require_common();
    var _cd = require_cd();
    var path = __require("path");
    common.register("dirs", _dirs, {
      wrapOutput: false
    });
    common.register("pushd", _pushd, {
      wrapOutput: false
    });
    common.register("popd", _popd, {
      wrapOutput: false
    });
    var _dirStack = [];
    function _isStackIndex(index) {
      return /^[\-+]\d+$/.test(index);
    }
    function _parseStackIndex(index) {
      if (_isStackIndex(index)) {
        if (Math.abs(index) < _dirStack.length + 1) {
          return /^-/.test(index) ? Number(index) - 1 : Number(index);
        }
        common.error(index + ": directory stack index out of range");
      } else {
        common.error(index + ": invalid number");
      }
    }
    function _actualDirStack() {
      return [process.cwd()].concat(_dirStack);
    }
    function _pushd(options, dir) {
      if (_isStackIndex(options)) {
        dir = options;
        options = "";
      }
      options = common.parseOptions(options, {
        "n": "no-cd",
        "q": "quiet"
      });
      var dirs = _actualDirStack();
      if (dir === "+0") {
        return dirs;
      } else if (!dir) {
        if (dirs.length > 1) {
          dirs = dirs.splice(1, 1).concat(dirs);
        } else {
          return common.error("no other directory");
        }
      } else if (_isStackIndex(dir)) {
        var n = _parseStackIndex(dir);
        dirs = dirs.slice(n).concat(dirs.slice(0, n));
      } else {
        if (options["no-cd"]) {
          dirs.splice(1, 0, dir);
        } else {
          dirs.unshift(dir);
        }
      }
      if (options["no-cd"]) {
        dirs = dirs.slice(1);
      } else {
        dir = path.resolve(dirs.shift());
        _cd("", dir);
      }
      _dirStack = dirs;
      return _dirs(options.quiet ? "-q" : "");
    }
    exports.pushd = _pushd;
    function _popd(options, index) {
      if (_isStackIndex(options)) {
        index = options;
        options = "";
      }
      options = common.parseOptions(options, {
        "n": "no-cd",
        "q": "quiet"
      });
      if (!_dirStack.length) {
        return common.error("directory stack empty");
      }
      index = _parseStackIndex(index || "+0");
      if (options["no-cd"] || index > 0 || _dirStack.length + index === 0) {
        index = index > 0 ? index - 1 : index;
        _dirStack.splice(index, 1);
      } else {
        var dir = path.resolve(_dirStack.shift());
        _cd("", dir);
      }
      return _dirs(options.quiet ? "-q" : "");
    }
    exports.popd = _popd;
    function _dirs(options, index) {
      if (_isStackIndex(options)) {
        index = options;
        options = "";
      }
      options = common.parseOptions(options, {
        "c": "clear",
        "q": "quiet"
      });
      if (options.clear) {
        _dirStack = [];
        return _dirStack;
      }
      var stack = _actualDirStack();
      if (index) {
        index = _parseStackIndex(index);
        if (index < 0) {
          index = stack.length + index;
        }
        if (!options.quiet) {
          common.log(stack[index]);
        }
        return stack[index];
      }
      if (!options.quiet) {
        common.log(stack.join(" "));
      }
      return stack;
    }
    exports.dirs = _dirs;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/echo.js
var require_echo = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/echo.js"(exports, module) {
    init_cjs_shims();
    var format = __require("util").format;
    var common = require_common();
    common.register("echo", _echo, {
      allowGlobbing: false
    });
    function _echo(opts) {
      var messages = [].slice.call(arguments, opts ? 0 : 1);
      var options = {};
      try {
        options = common.parseOptions(messages[0], {
          "e": "escapes",
          "n": "no_newline"
        }, {
          silent: true
        });
        if (messages[0]) {
          messages.shift();
        }
      } catch (_) {
        common.state.error = null;
      }
      var output = format.apply(null, messages);
      if (!options.no_newline) {
        output += "\n";
      }
      process.stdout.write(output);
      return output;
    }
    module.exports = _echo;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/error.js
var require_error = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/error.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    function error() {
      return common.state.error;
    }
    module.exports = error;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/exec-child.js
var require_exec_child = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/exec-child.js"(exports, module) {
    init_cjs_shims();
    if (__require.main !== module) {
      throw new Error("This file should not be required");
    }
    var childProcess = __require("child_process");
    var fs = __require("fs");
    var paramFilePath = process.argv[2];
    var serializedParams = fs.readFileSync(paramFilePath, "utf8");
    var params = JSON.parse(serializedParams);
    var cmd = params.command;
    var execOptions = params.execOptions;
    var pipe = params.pipe;
    var stdoutFile = params.stdoutFile;
    var stderrFile = params.stderrFile;
    var c = childProcess.exec(cmd, execOptions, function(err) {
      if (!err) {
        process.exitCode = 0;
      } else if (err.code === void 0) {
        process.exitCode = 1;
      } else {
        process.exitCode = err.code;
      }
    });
    var stdoutStream = fs.createWriteStream(stdoutFile);
    var stderrStream = fs.createWriteStream(stderrFile);
    c.stdout.pipe(stdoutStream);
    c.stderr.pipe(stderrStream);
    c.stdout.pipe(process.stdout);
    c.stderr.pipe(process.stderr);
    if (pipe) {
      c.stdin.end(pipe);
    }
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/tempdir.js
var require_tempdir = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/tempdir.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var os = __require("os");
    var fs = __require("fs");
    common.register("tempdir", _tempDir, {
      allowGlobbing: false,
      wrapOutput: false
    });
    function writeableDir(dir) {
      if (!dir || !fs.existsSync(dir))
        return false;
      if (!common.statFollowLinks(dir).isDirectory())
        return false;
      var testFile = dir + "/" + common.randomFileName();
      try {
        fs.writeFileSync(testFile, " ");
        common.unlinkSync(testFile);
        return dir;
      } catch (e) {
        return false;
      }
    }
    var cachedTempDir;
    function _tempDir() {
      if (cachedTempDir)
        return cachedTempDir;
      cachedTempDir = writeableDir(os.tmpdir()) || writeableDir(process.env.TMPDIR) || writeableDir(process.env.TEMP) || writeableDir(process.env.TMP) || writeableDir(process.env.Wimp$ScrapDir) || // RiscOS
      writeableDir("C:\\TEMP") || // Windows
      writeableDir("C:\\TMP") || // Windows
      writeableDir("\\TEMP") || // Windows
      writeableDir("\\TMP") || // Windows
      writeableDir("/tmp") || writeableDir("/var/tmp") || writeableDir("/usr/tmp") || writeableDir(".");
      return cachedTempDir;
    }
    function isCached() {
      return cachedTempDir;
    }
    function clearCache() {
      cachedTempDir = void 0;
    }
    module.exports.tempDir = _tempDir;
    module.exports.isCached = isCached;
    module.exports.clearCache = clearCache;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/pwd.js
var require_pwd = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/pwd.js"(exports, module) {
    init_cjs_shims();
    var path = __require("path");
    var common = require_common();
    common.register("pwd", _pwd, {
      allowGlobbing: false
    });
    function _pwd() {
      var pwd = path.resolve(process.cwd());
      return pwd;
    }
    module.exports = _pwd;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/exec.js
var require_exec = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/exec.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var _tempDir = require_tempdir().tempDir;
    var _pwd = require_pwd();
    var path = __require("path");
    var fs = __require("fs");
    var child = __require("child_process");
    var DEFAULT_MAXBUFFER_SIZE = 20 * 1024 * 1024;
    var DEFAULT_ERROR_CODE = 1;
    common.register("exec", _exec, {
      unix: false,
      canReceivePipe: true,
      wrapOutput: false
    });
    function execSync(cmd, opts, pipe) {
      if (!common.config.execPath) {
        common.error("Unable to find a path to the node binary. Please manually set config.execPath");
      }
      var tempDir = _tempDir();
      var paramsFile = path.resolve(tempDir + "/" + common.randomFileName());
      var stderrFile = path.resolve(tempDir + "/" + common.randomFileName());
      var stdoutFile = path.resolve(tempDir + "/" + common.randomFileName());
      opts = common.extend({
        silent: common.config.silent,
        cwd: _pwd().toString(),
        env: process.env,
        maxBuffer: DEFAULT_MAXBUFFER_SIZE,
        encoding: "utf8"
      }, opts);
      if (fs.existsSync(paramsFile))
        common.unlinkSync(paramsFile);
      if (fs.existsSync(stderrFile))
        common.unlinkSync(stderrFile);
      if (fs.existsSync(stdoutFile))
        common.unlinkSync(stdoutFile);
      opts.cwd = path.resolve(opts.cwd);
      var paramsToSerialize = {
        command: cmd,
        execOptions: opts,
        pipe,
        stdoutFile,
        stderrFile
      };
      function writeFileLockedDown(filePath, data) {
        fs.writeFileSync(filePath, data, {
          encoding: "utf8",
          mode: parseInt("600", 8)
        });
      }
      writeFileLockedDown(stdoutFile, "");
      writeFileLockedDown(stderrFile, "");
      writeFileLockedDown(paramsFile, JSON.stringify(paramsToSerialize));
      var execArgs = [
        path.join(__dirname, "exec-child.js"),
        paramsFile
      ];
      if (opts.silent) {
        opts.stdio = "ignore";
      } else {
        opts.stdio = [0, 1, 2];
      }
      var code = 0;
      try {
        delete opts.shell;
        child.execFileSync(common.config.execPath, execArgs, opts);
      } catch (e) {
        code = e.status || DEFAULT_ERROR_CODE;
      }
      var stdout = "";
      var stderr = "";
      if (opts.encoding === "buffer") {
        stdout = fs.readFileSync(stdoutFile);
        stderr = fs.readFileSync(stderrFile);
      } else {
        stdout = fs.readFileSync(stdoutFile, opts.encoding);
        stderr = fs.readFileSync(stderrFile, opts.encoding);
      }
      try {
        common.unlinkSync(paramsFile);
      } catch (e) {
      }
      try {
        common.unlinkSync(stderrFile);
      } catch (e) {
      }
      try {
        common.unlinkSync(stdoutFile);
      } catch (e) {
      }
      if (code !== 0) {
        common.error(stderr, code, { continue: true, silent: true });
      }
      var obj = common.ShellString(stdout, stderr, code);
      return obj;
    }
    function execAsync(cmd, opts, pipe, callback) {
      opts = common.extend({
        silent: common.config.silent,
        cwd: _pwd().toString(),
        env: process.env,
        maxBuffer: DEFAULT_MAXBUFFER_SIZE,
        encoding: "utf8"
      }, opts);
      var c = child.exec(cmd, opts, function(err, stdout, stderr) {
        if (callback) {
          if (!err) {
            callback(0, stdout, stderr);
          } else if (err.code === void 0) {
            callback(1, stdout, stderr);
          } else {
            callback(err.code, stdout, stderr);
          }
        }
      });
      if (pipe)
        c.stdin.end(pipe);
      if (!opts.silent) {
        c.stdout.pipe(process.stdout);
        c.stderr.pipe(process.stderr);
      }
      return c;
    }
    function _exec(command, options, callback) {
      options = options || {};
      if (!command)
        common.error("must specify command");
      var pipe = common.readFromPipe();
      if (typeof options === "function") {
        callback = options;
        options = { async: true };
      }
      if (typeof options === "object" && typeof callback === "function") {
        options.async = true;
      }
      options = common.extend({
        silent: common.config.silent,
        async: false
      }, options);
      if (options.async) {
        return execAsync(command, options, pipe, callback);
      } else {
        return execSync(command, options, pipe);
      }
    }
    module.exports = _exec;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/ls.js
var require_ls = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/ls.js"(exports, module) {
    init_cjs_shims();
    var path = __require("path");
    var fs = __require("fs");
    var common = require_common();
    var glob = require_glob();
    var globPatternRecursive = path.sep + "**";
    common.register("ls", _ls, {
      cmdOptions: {
        "R": "recursive",
        "A": "all",
        "L": "link",
        "a": "all_deprecated",
        "d": "directory",
        "l": "long"
      }
    });
    function _ls(options, paths) {
      if (options.all_deprecated) {
        common.log("ls: Option -a is deprecated. Use -A instead");
        options.all = true;
      }
      if (!paths) {
        paths = ["."];
      } else {
        paths = [].slice.call(arguments, 1);
      }
      var list = [];
      function pushFile(abs, relName, stat) {
        if (process.platform === "win32") {
          relName = relName.replace(/\\/g, "/");
        }
        if (options.long) {
          stat = stat || (options.link ? common.statFollowLinks(abs) : common.statNoFollowLinks(abs));
          list.push(addLsAttributes(relName, stat));
        } else {
          list.push(relName);
        }
      }
      paths.forEach(function(p) {
        var stat;
        try {
          stat = options.link ? common.statFollowLinks(p) : common.statNoFollowLinks(p);
          if (stat.isSymbolicLink()) {
            try {
              var _stat = common.statFollowLinks(p);
              if (_stat.isDirectory()) {
                stat = _stat;
              }
            } catch (_) {
            }
          }
        } catch (e) {
          common.error("no such file or directory: " + p, 2, { continue: true });
          return;
        }
        if (stat.isDirectory() && !options.directory) {
          if (options.recursive) {
            glob.sync(p + globPatternRecursive, { dot: options.all, follow: options.link }).forEach(function(item) {
              if (path.relative(p, item)) {
                pushFile(item, path.relative(p, item));
              }
            });
          } else if (options.all) {
            fs.readdirSync(p).forEach(function(item) {
              pushFile(path.join(p, item), item);
            });
          } else {
            fs.readdirSync(p).forEach(function(item) {
              if (item[0] !== ".") {
                pushFile(path.join(p, item), item);
              }
            });
          }
        } else {
          pushFile(p, p, stat);
        }
      });
      return list;
    }
    function addLsAttributes(pathName, stats) {
      stats.name = pathName;
      stats.toString = function() {
        return [this.mode, this.nlink, this.uid, this.gid, this.size, this.mtime, this.name].join(" ");
      };
      return stats;
    }
    module.exports = _ls;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/find.js
var require_find = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/find.js"(exports, module) {
    init_cjs_shims();
    var path = __require("path");
    var common = require_common();
    var _ls = require_ls();
    common.register("find", _find, {});
    function _find(options, paths) {
      if (!paths) {
        common.error("no path specified");
      } else if (typeof paths === "string") {
        paths = [].slice.call(arguments, 1);
      }
      var list = [];
      function pushFile(file) {
        if (process.platform === "win32") {
          file = file.replace(/\\/g, "/");
        }
        list.push(file);
      }
      paths.forEach(function(file) {
        var stat;
        try {
          stat = common.statFollowLinks(file);
        } catch (e) {
          common.error("no such file or directory: " + file);
        }
        pushFile(file);
        if (stat.isDirectory()) {
          _ls({ recursive: true, all: true }, file).forEach(function(subfile) {
            pushFile(path.join(file, subfile));
          });
        }
      });
      return list;
    }
    module.exports = _find;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/grep.js
var require_grep = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/grep.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("grep", _grep, {
      globStart: 2,
      // don't glob-expand the regex
      canReceivePipe: true,
      cmdOptions: {
        "v": "inverse",
        "l": "nameOnly",
        "i": "ignoreCase"
      }
    });
    function _grep(options, regex, files) {
      var pipe = common.readFromPipe();
      if (!files && !pipe)
        common.error("no paths given", 2);
      files = [].slice.call(arguments, 2);
      if (pipe) {
        files.unshift("-");
      }
      var grep = [];
      if (options.ignoreCase) {
        regex = new RegExp(regex, "i");
      }
      files.forEach(function(file) {
        if (!fs.existsSync(file) && file !== "-") {
          common.error("no such file or directory: " + file, 2, { continue: true });
          return;
        }
        var contents = file === "-" ? pipe : fs.readFileSync(file, "utf8");
        if (options.nameOnly) {
          if (contents.match(regex)) {
            grep.push(file);
          }
        } else {
          var lines = contents.split("\n");
          lines.forEach(function(line) {
            var matched = line.match(regex);
            if (options.inverse && !matched || !options.inverse && matched) {
              grep.push(line);
            }
          });
        }
      });
      return grep.join("\n") + "\n";
    }
    module.exports = _grep;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/head.js
var require_head = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/head.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("head", _head, {
      canReceivePipe: true,
      cmdOptions: {
        "n": "numLines"
      }
    });
    function readSomeLines(file, numLines) {
      var buf = common.buffer();
      var bufLength = buf.length;
      var bytesRead = bufLength;
      var pos = 0;
      var fdr = fs.openSync(file, "r");
      var numLinesRead = 0;
      var ret = "";
      while (bytesRead === bufLength && numLinesRead < numLines) {
        bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);
        var bufStr = buf.toString("utf8", 0, bytesRead);
        numLinesRead += bufStr.split("\n").length - 1;
        ret += bufStr;
        pos += bytesRead;
      }
      fs.closeSync(fdr);
      return ret;
    }
    function _head(options, files) {
      var head = [];
      var pipe = common.readFromPipe();
      if (!files && !pipe)
        common.error("no paths given");
      var idx = 1;
      if (options.numLines === true) {
        idx = 2;
        options.numLines = Number(arguments[1]);
      } else if (options.numLines === false) {
        options.numLines = 10;
      }
      files = [].slice.call(arguments, idx);
      if (pipe) {
        files.unshift("-");
      }
      var shouldAppendNewline = false;
      files.forEach(function(file) {
        if (file !== "-") {
          if (!fs.existsSync(file)) {
            common.error("no such file or directory: " + file, { continue: true });
            return;
          } else if (common.statFollowLinks(file).isDirectory()) {
            common.error("error reading '" + file + "': Is a directory", {
              continue: true
            });
            return;
          }
        }
        var contents;
        if (file === "-") {
          contents = pipe;
        } else if (options.numLines < 0) {
          contents = fs.readFileSync(file, "utf8");
        } else {
          contents = readSomeLines(file, options.numLines);
        }
        var lines = contents.split("\n");
        var hasTrailingNewline = lines[lines.length - 1] === "";
        if (hasTrailingNewline) {
          lines.pop();
        }
        shouldAppendNewline = hasTrailingNewline || options.numLines < lines.length;
        head = head.concat(lines.slice(0, options.numLines));
      });
      if (shouldAppendNewline) {
        head.push("");
      }
      return head.join("\n");
    }
    module.exports = _head;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/ln.js
var require_ln = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/ln.js"(exports, module) {
    init_cjs_shims();
    var fs = __require("fs");
    var path = __require("path");
    var common = require_common();
    common.register("ln", _ln, {
      cmdOptions: {
        "s": "symlink",
        "f": "force"
      }
    });
    function _ln(options, source, dest) {
      if (!source || !dest) {
        common.error("Missing <source> and/or <dest>");
      }
      source = String(source);
      var sourcePath = path.normalize(source).replace(RegExp(path.sep + "$"), "");
      var isAbsolute = path.resolve(source) === sourcePath;
      dest = path.resolve(process.cwd(), String(dest));
      if (fs.existsSync(dest)) {
        if (!options.force) {
          common.error("Destination file exists", { continue: true });
        }
        fs.unlinkSync(dest);
      }
      if (options.symlink) {
        var isWindows = process.platform === "win32";
        var linkType = isWindows ? "file" : null;
        var resolvedSourcePath = isAbsolute ? sourcePath : path.resolve(process.cwd(), path.dirname(dest), source);
        if (!fs.existsSync(resolvedSourcePath)) {
          common.error("Source file does not exist", { continue: true });
        } else if (isWindows && common.statFollowLinks(resolvedSourcePath).isDirectory()) {
          linkType = "junction";
        }
        try {
          fs.symlinkSync(linkType === "junction" ? resolvedSourcePath : source, dest, linkType);
        } catch (err) {
          common.error(err.message);
        }
      } else {
        if (!fs.existsSync(source)) {
          common.error("Source file does not exist", { continue: true });
        }
        try {
          fs.linkSync(source, dest);
        } catch (err) {
          common.error(err.message);
        }
      }
      return "";
    }
    module.exports = _ln;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/mkdir.js
var require_mkdir = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/mkdir.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    var path = __require("path");
    common.register("mkdir", _mkdir, {
      cmdOptions: {
        "p": "fullpath"
      }
    });
    function mkdirSyncRecursive(dir) {
      var baseDir = path.dirname(dir);
      if (baseDir === dir) {
        common.error("dirname() failed: [" + dir + "]");
      }
      if (fs.existsSync(baseDir)) {
        fs.mkdirSync(dir, parseInt("0777", 8));
        return;
      }
      mkdirSyncRecursive(baseDir);
      fs.mkdirSync(dir, parseInt("0777", 8));
    }
    function _mkdir(options, dirs) {
      if (!dirs)
        common.error("no paths given");
      if (typeof dirs === "string") {
        dirs = [].slice.call(arguments, 1);
      }
      dirs.forEach(function(dir) {
        try {
          var stat = common.statNoFollowLinks(dir);
          if (!options.fullpath) {
            common.error("path already exists: " + dir, { continue: true });
          } else if (stat.isFile()) {
            common.error("cannot create directory " + dir + ": File exists", { continue: true });
          }
          return;
        } catch (e) {
        }
        var baseDir = path.dirname(dir);
        if (!fs.existsSync(baseDir) && !options.fullpath) {
          common.error("no such file or directory: " + baseDir, { continue: true });
          return;
        }
        try {
          if (options.fullpath) {
            mkdirSyncRecursive(path.resolve(dir));
          } else {
            fs.mkdirSync(dir, parseInt("0777", 8));
          }
        } catch (e) {
          var reason;
          if (e.code === "EACCES") {
            reason = "Permission denied";
          } else if (e.code === "ENOTDIR" || e.code === "ENOENT") {
            reason = "Not a directory";
          } else {
            throw e;
          }
          common.error("cannot create directory " + dir + ": " + reason, { continue: true });
        }
      });
      return "";
    }
    module.exports = _mkdir;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/rm.js
var require_rm = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/rm.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("rm", _rm, {
      cmdOptions: {
        "f": "force",
        "r": "recursive",
        "R": "recursive"
      }
    });
    function rmdirSyncRecursive(dir, force, fromSymlink) {
      var files;
      files = fs.readdirSync(dir);
      for (var i = 0; i < files.length; i++) {
        var file = dir + "/" + files[i];
        var currFile = common.statNoFollowLinks(file);
        if (currFile.isDirectory()) {
          rmdirSyncRecursive(file, force);
        } else {
          if (force || isWriteable(file)) {
            try {
              common.unlinkSync(file);
            } catch (e) {
              common.error("could not remove file (code " + e.code + "): " + file, {
                continue: true
              });
            }
          }
        }
      }
      if (fromSymlink)
        return;
      var result;
      try {
        var start = Date.now();
        for (; ; ) {
          try {
            result = fs.rmdirSync(dir);
            if (fs.existsSync(dir))
              throw { code: "EAGAIN" };
            break;
          } catch (er) {
            if (process.platform === "win32" && (er.code === "ENOTEMPTY" || er.code === "EBUSY" || er.code === "EPERM" || er.code === "EAGAIN")) {
              if (Date.now() - start > 1e3)
                throw er;
            } else if (er.code === "ENOENT") {
              break;
            } else {
              throw er;
            }
          }
        }
      } catch (e) {
        common.error("could not remove directory (code " + e.code + "): " + dir, { continue: true });
      }
      return result;
    }
    function isWriteable(file) {
      var writePermission = true;
      try {
        var __fd = fs.openSync(file, "a");
        fs.closeSync(__fd);
      } catch (e) {
        writePermission = false;
      }
      return writePermission;
    }
    function handleFile(file, options) {
      if (options.force || isWriteable(file)) {
        common.unlinkSync(file);
      } else {
        common.error("permission denied: " + file, { continue: true });
      }
    }
    function handleDirectory(file, options) {
      if (options.recursive) {
        rmdirSyncRecursive(file, options.force);
      } else {
        common.error("path is a directory", { continue: true });
      }
    }
    function handleSymbolicLink(file, options) {
      var stats;
      try {
        stats = common.statFollowLinks(file);
      } catch (e) {
        common.unlinkSync(file);
        return;
      }
      if (stats.isFile()) {
        common.unlinkSync(file);
      } else if (stats.isDirectory()) {
        if (file[file.length - 1] === "/") {
          if (options.recursive) {
            var fromSymlink = true;
            rmdirSyncRecursive(file, options.force, fromSymlink);
          } else {
            common.error("path is a directory", { continue: true });
          }
        } else {
          common.unlinkSync(file);
        }
      }
    }
    function handleFIFO(file) {
      common.unlinkSync(file);
    }
    function _rm(options, files) {
      if (!files)
        common.error("no paths given");
      files = [].slice.call(arguments, 1);
      files.forEach(function(file) {
        var lstats;
        try {
          var filepath = file[file.length - 1] === "/" ? file.slice(0, -1) : file;
          lstats = common.statNoFollowLinks(filepath);
        } catch (e) {
          if (!options.force) {
            common.error("no such file or directory: " + file, { continue: true });
          }
          return;
        }
        if (lstats.isFile()) {
          handleFile(file, options);
        } else if (lstats.isDirectory()) {
          handleDirectory(file, options);
        } else if (lstats.isSymbolicLink()) {
          handleSymbolicLink(file, options);
        } else if (lstats.isFIFO()) {
          handleFIFO(file);
        }
      });
      return "";
    }
    module.exports = _rm;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/mv.js
var require_mv = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/mv.js"(exports, module) {
    init_cjs_shims();
    var fs = __require("fs");
    var path = __require("path");
    var common = require_common();
    var cp = require_cp();
    var rm = require_rm();
    common.register("mv", _mv, {
      cmdOptions: {
        "f": "!no_force",
        "n": "no_force"
      }
    });
    function checkRecentCreated(sources, index) {
      var lookedSource = sources[index];
      return sources.slice(0, index).some(function(src) {
        return path.basename(src) === path.basename(lookedSource);
      });
    }
    function _mv(options, sources, dest) {
      if (arguments.length < 3) {
        common.error("missing <source> and/or <dest>");
      } else if (arguments.length > 3) {
        sources = [].slice.call(arguments, 1, arguments.length - 1);
        dest = arguments[arguments.length - 1];
      } else if (typeof sources === "string") {
        sources = [sources];
      } else {
        common.error("invalid arguments");
      }
      var exists = fs.existsSync(dest);
      var stats = exists && common.statFollowLinks(dest);
      if ((!exists || !stats.isDirectory()) && sources.length > 1) {
        common.error("dest is not a directory (too many sources)");
      }
      if (exists && stats.isFile() && options.no_force) {
        common.error("dest file already exists: " + dest);
      }
      sources.forEach(function(src, srcIndex) {
        if (!fs.existsSync(src)) {
          common.error("no such file or directory: " + src, { continue: true });
          return;
        }
        var thisDest = dest;
        if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {
          thisDest = path.normalize(dest + "/" + path.basename(src));
        }
        var thisDestExists = fs.existsSync(thisDest);
        if (thisDestExists && checkRecentCreated(sources, srcIndex)) {
          if (!options.no_force) {
            common.error("will not overwrite just-created '" + thisDest + "' with '" + src + "'", { continue: true });
          }
          return;
        }
        if (fs.existsSync(thisDest) && options.no_force) {
          common.error("dest file already exists: " + thisDest, { continue: true });
          return;
        }
        if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {
          common.error("cannot move to self: " + src, { continue: true });
          return;
        }
        try {
          fs.renameSync(src, thisDest);
        } catch (e) {
          if (e.code === "EXDEV") {
            cp("-r", src, thisDest);
            rm("-rf", src);
          }
        }
      });
      return "";
    }
    module.exports = _mv;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/popd.js
var require_popd = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/popd.js"() {
    init_cjs_shims();
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/pushd.js
var require_pushd = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/pushd.js"() {
    init_cjs_shims();
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/sed.js
var require_sed = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/sed.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("sed", _sed, {
      globStart: 3,
      // don't glob-expand regexes
      canReceivePipe: true,
      cmdOptions: {
        "i": "inplace"
      }
    });
    function _sed(options, regex, replacement, files) {
      var pipe = common.readFromPipe();
      if (typeof replacement !== "string" && typeof replacement !== "function") {
        if (typeof replacement === "number") {
          replacement = replacement.toString();
        } else {
          common.error("invalid replacement string");
        }
      }
      if (typeof regex === "string") {
        regex = RegExp(regex);
      }
      if (!files && !pipe) {
        common.error("no files given");
      }
      files = [].slice.call(arguments, 3);
      if (pipe) {
        files.unshift("-");
      }
      var sed = [];
      files.forEach(function(file) {
        if (!fs.existsSync(file) && file !== "-") {
          common.error("no such file or directory: " + file, 2, { continue: true });
          return;
        }
        var contents = file === "-" ? pipe : fs.readFileSync(file, "utf8");
        var lines = contents.split("\n");
        var result = lines.map(function(line) {
          return line.replace(regex, replacement);
        }).join("\n");
        sed.push(result);
        if (options.inplace) {
          fs.writeFileSync(file, result, "utf8");
        }
      });
      return sed.join("\n");
    }
    module.exports = _sed;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/set.js
var require_set = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/set.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    common.register("set", _set, {
      allowGlobbing: false,
      wrapOutput: false
    });
    function _set(options) {
      if (!options) {
        var args = [].slice.call(arguments, 0);
        if (args.length < 2)
          common.error("must provide an argument");
        options = args[1];
      }
      var negate = options[0] === "+";
      if (negate) {
        options = "-" + options.slice(1);
      }
      options = common.parseOptions(options, {
        "e": "fatal",
        "v": "verbose",
        "f": "noglob"
      });
      if (negate) {
        Object.keys(options).forEach(function(key) {
          options[key] = !options[key];
        });
      }
      Object.keys(options).forEach(function(key) {
        if (negate !== options[key]) {
          common.config[key] = options[key];
        }
      });
      return;
    }
    module.exports = _set;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/sort.js
var require_sort = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/sort.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("sort", _sort, {
      canReceivePipe: true,
      cmdOptions: {
        "r": "reverse",
        "n": "numerical"
      }
    });
    function parseNumber(str) {
      var match = str.match(/^\s*(\d*)\s*(.*)$/);
      return { num: Number(match[1]), value: match[2] };
    }
    function unixCmp(a, b) {
      var aLower = a.toLowerCase();
      var bLower = b.toLowerCase();
      return aLower === bLower ? -1 * a.localeCompare(b) : (
        // unix sort treats case opposite how javascript does
        aLower.localeCompare(bLower)
      );
    }
    function numericalCmp(a, b) {
      var objA = parseNumber(a);
      var objB = parseNumber(b);
      if (objA.hasOwnProperty("num") && objB.hasOwnProperty("num")) {
        return objA.num !== objB.num ? objA.num - objB.num : unixCmp(objA.value, objB.value);
      } else {
        return unixCmp(objA.value, objB.value);
      }
    }
    function _sort(options, files) {
      var pipe = common.readFromPipe();
      if (!files && !pipe)
        common.error("no files given");
      files = [].slice.call(arguments, 1);
      if (pipe) {
        files.unshift("-");
      }
      var lines = files.reduce(function(accum, file) {
        if (file !== "-") {
          if (!fs.existsSync(file)) {
            common.error("no such file or directory: " + file, { continue: true });
            return accum;
          } else if (common.statFollowLinks(file).isDirectory()) {
            common.error("read failed: " + file + ": Is a directory", {
              continue: true
            });
            return accum;
          }
        }
        var contents = file === "-" ? pipe : fs.readFileSync(file, "utf8");
        return accum.concat(contents.trimRight().split("\n"));
      }, []);
      var sorted = lines.sort(options.numerical ? numericalCmp : unixCmp);
      if (options.reverse) {
        sorted = sorted.reverse();
      }
      return sorted.join("\n") + "\n";
    }
    module.exports = _sort;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/tail.js
var require_tail = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/tail.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("tail", _tail, {
      canReceivePipe: true,
      cmdOptions: {
        "n": "numLines"
      }
    });
    function _tail(options, files) {
      var tail = [];
      var pipe = common.readFromPipe();
      if (!files && !pipe)
        common.error("no paths given");
      var idx = 1;
      if (options.numLines === true) {
        idx = 2;
        options.numLines = Number(arguments[1]);
      } else if (options.numLines === false) {
        options.numLines = 10;
      }
      options.numLines = -1 * Math.abs(options.numLines);
      files = [].slice.call(arguments, idx);
      if (pipe) {
        files.unshift("-");
      }
      var shouldAppendNewline = false;
      files.forEach(function(file) {
        if (file !== "-") {
          if (!fs.existsSync(file)) {
            common.error("no such file or directory: " + file, { continue: true });
            return;
          } else if (common.statFollowLinks(file).isDirectory()) {
            common.error("error reading '" + file + "': Is a directory", {
              continue: true
            });
            return;
          }
        }
        var contents = file === "-" ? pipe : fs.readFileSync(file, "utf8");
        var lines = contents.split("\n");
        if (lines[lines.length - 1] === "") {
          lines.pop();
          shouldAppendNewline = true;
        } else {
          shouldAppendNewline = false;
        }
        tail = tail.concat(lines.slice(options.numLines));
      });
      if (shouldAppendNewline) {
        tail.push("");
      }
      return tail.join("\n");
    }
    module.exports = _tail;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/test.js
var require_test = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/test.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("test", _test, {
      cmdOptions: {
        "b": "block",
        "c": "character",
        "d": "directory",
        "e": "exists",
        "f": "file",
        "L": "link",
        "p": "pipe",
        "S": "socket"
      },
      wrapOutput: false,
      allowGlobbing: false
    });
    function _test(options, path) {
      if (!path)
        common.error("no path given");
      var canInterpret = false;
      Object.keys(options).forEach(function(key) {
        if (options[key] === true) {
          canInterpret = true;
        }
      });
      if (!canInterpret)
        common.error("could not interpret expression");
      if (options.link) {
        try {
          return common.statNoFollowLinks(path).isSymbolicLink();
        } catch (e) {
          return false;
        }
      }
      if (!fs.existsSync(path))
        return false;
      if (options.exists)
        return true;
      var stats = common.statFollowLinks(path);
      if (options.block)
        return stats.isBlockDevice();
      if (options.character)
        return stats.isCharacterDevice();
      if (options.directory)
        return stats.isDirectory();
      if (options.file)
        return stats.isFile();
      if (options.pipe)
        return stats.isFIFO();
      if (options.socket)
        return stats.isSocket();
      return false;
    }
    module.exports = _test;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/to.js
var require_to = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/to.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    var path = __require("path");
    common.register("to", _to, {
      pipeOnly: true,
      wrapOutput: false
    });
    function _to(options, file) {
      if (!file)
        common.error("wrong arguments");
      if (!fs.existsSync(path.dirname(file))) {
        common.error("no such file or directory: " + path.dirname(file));
      }
      try {
        fs.writeFileSync(file, this.stdout || this.toString(), "utf8");
        return this;
      } catch (e) {
        common.error("could not write to file (code " + e.code + "): " + file, { continue: true });
      }
    }
    module.exports = _to;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/toEnd.js
var require_toEnd = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/toEnd.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    var path = __require("path");
    common.register("toEnd", _toEnd, {
      pipeOnly: true,
      wrapOutput: false
    });
    function _toEnd(options, file) {
      if (!file)
        common.error("wrong arguments");
      if (!fs.existsSync(path.dirname(file))) {
        common.error("no such file or directory: " + path.dirname(file));
      }
      try {
        fs.appendFileSync(file, this.stdout || this.toString(), "utf8");
        return this;
      } catch (e) {
        common.error("could not append to file (code " + e.code + "): " + file, { continue: true });
      }
    }
    module.exports = _toEnd;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/touch.js
var require_touch = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/touch.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    common.register("touch", _touch, {
      cmdOptions: {
        "a": "atime_only",
        "c": "no_create",
        "d": "date",
        "m": "mtime_only",
        "r": "reference"
      }
    });
    function _touch(opts, files) {
      if (!files) {
        common.error("no files given");
      } else if (typeof files === "string") {
        files = [].slice.call(arguments, 1);
      } else {
        common.error("file arg should be a string file path or an Array of string file paths");
      }
      files.forEach(function(f) {
        touchFile(opts, f);
      });
      return "";
    }
    function touchFile(opts, file) {
      var stat = tryStatFile(file);
      if (stat && stat.isDirectory()) {
        return;
      }
      if (!stat && opts.no_create) {
        return;
      }
      fs.closeSync(fs.openSync(file, "a"));
      var now = /* @__PURE__ */ new Date();
      var mtime = opts.date || now;
      var atime = opts.date || now;
      if (opts.reference) {
        var refStat = tryStatFile(opts.reference);
        if (!refStat) {
          common.error("failed to get attributess of " + opts.reference);
        }
        mtime = refStat.mtime;
        atime = refStat.atime;
      } else if (opts.date) {
        mtime = opts.date;
        atime = opts.date;
      }
      if (opts.atime_only && opts.mtime_only) {
      } else if (opts.atime_only) {
        mtime = stat.mtime;
      } else if (opts.mtime_only) {
        atime = stat.atime;
      }
      fs.utimesSync(file, atime, mtime);
    }
    module.exports = _touch;
    function tryStatFile(filePath) {
      try {
        return common.statFollowLinks(filePath);
      } catch (e) {
        return null;
      }
    }
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/uniq.js
var require_uniq = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/uniq.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    function lpad(c, str) {
      var res = "" + str;
      if (res.length < c) {
        res = Array(c - res.length + 1).join(" ") + res;
      }
      return res;
    }
    common.register("uniq", _uniq, {
      canReceivePipe: true,
      cmdOptions: {
        "i": "ignoreCase",
        "c": "count",
        "d": "duplicates"
      }
    });
    function _uniq(options, input, output) {
      var pipe = common.readFromPipe();
      if (!pipe) {
        if (!input)
          common.error("no input given");
        if (!fs.existsSync(input)) {
          common.error(input + ": No such file or directory");
        } else if (common.statFollowLinks(input).isDirectory()) {
          common.error("error reading '" + input + "'");
        }
      }
      if (output && fs.existsSync(output) && common.statFollowLinks(output).isDirectory()) {
        common.error(output + ": Is a directory");
      }
      var lines = (input ? fs.readFileSync(input, "utf8") : pipe).trimRight().split("\n");
      var compare = function(a, b) {
        return options.ignoreCase ? a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase()) : a.localeCompare(b);
      };
      var uniqed = lines.reduceRight(function(res, e) {
        if (res.length === 0) {
          return [{ count: 1, ln: e }];
        } else if (compare(res[0].ln, e) === 0) {
          return [{ count: res[0].count + 1, ln: e }].concat(res.slice(1));
        } else {
          return [{ count: 1, ln: e }].concat(res);
        }
      }, []).filter(function(obj) {
        return options.duplicates ? obj.count > 1 : true;
      }).map(function(obj) {
        return (options.count ? lpad(7, obj.count) + " " : "") + obj.ln;
      }).join("\n") + "\n";
      if (output) {
        new common.ShellString(uniqed).to(output);
        return "";
      } else {
        return uniqed;
      }
    }
    module.exports = _uniq;
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/which.js
var require_which = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/src/which.js"(exports, module) {
    init_cjs_shims();
    var common = require_common();
    var fs = __require("fs");
    var path = __require("path");
    common.register("which", _which, {
      allowGlobbing: false,
      cmdOptions: {
        "a": "all"
      }
    });
    var XP_DEFAULT_PATHEXT = ".com;.exe;.bat;.cmd;.vbs;.vbe;.js;.jse;.wsf;.wsh";
    var FILE_EXECUTABLE_MODE = 1;
    function isWindowsPlatform() {
      return process.platform === "win32";
    }
    function splitPath(p) {
      return p ? p.split(path.delimiter) : [];
    }
    function isExecutable(pathName) {
      try {
        fs.accessSync(pathName, FILE_EXECUTABLE_MODE);
      } catch (err) {
        return false;
      }
      return true;
    }
    function checkPath(pathName) {
      return fs.existsSync(pathName) && !common.statFollowLinks(pathName).isDirectory() && (isWindowsPlatform() || isExecutable(pathName));
    }
    function _which(options, cmd) {
      if (!cmd)
        common.error("must specify command");
      var isWindows = isWindowsPlatform();
      var pathArray = splitPath(process.env.PATH);
      var queryMatches = [];
      if (cmd.indexOf("/") === -1) {
        var pathExtArray = [""];
        if (isWindows) {
          var pathExtEnv = process.env.PATHEXT || XP_DEFAULT_PATHEXT;
          pathExtArray = splitPath(pathExtEnv.toUpperCase());
        }
        for (var k = 0; k < pathArray.length; k++) {
          if (queryMatches.length > 0 && !options.all)
            break;
          var attempt = path.resolve(pathArray[k], cmd);
          if (isWindows) {
            attempt = attempt.toUpperCase();
          }
          var match = attempt.match(/\.[^<>:"/\|?*.]+$/);
          if (match && pathExtArray.indexOf(match[0]) >= 0) {
            if (checkPath(attempt)) {
              queryMatches.push(attempt);
              break;
            }
          } else {
            for (var i = 0; i < pathExtArray.length; i++) {
              var ext = pathExtArray[i];
              var newAttempt = attempt + ext;
              if (checkPath(newAttempt)) {
                queryMatches.push(newAttempt);
                break;
              }
            }
          }
        }
      } else if (checkPath(cmd)) {
        queryMatches.push(path.resolve(cmd));
      }
      if (queryMatches.length > 0) {
        return options.all ? queryMatches : queryMatches[0];
      }
      return options.all ? [] : null;
    }
    module.exports = _which;
  }
});

// require("./src/**/*") in ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/shell.js
var globRequire_src;
var init_ = __esm({
  'require("./src/**/*") in ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/shell.js'() {
    globRequire_src = __glob({
      "./src/cat.js": () => require_cat(),
      "./src/cd.js": () => require_cd(),
      "./src/chmod.js": () => require_chmod(),
      "./src/common.js": () => require_common(),
      "./src/cp.js": () => require_cp(),
      "./src/dirs.js": () => require_dirs(),
      "./src/echo.js": () => require_echo(),
      "./src/error.js": () => require_error(),
      "./src/exec-child.js": () => require_exec_child(),
      "./src/exec.js": () => require_exec(),
      "./src/find.js": () => require_find(),
      "./src/grep.js": () => require_grep(),
      "./src/head.js": () => require_head(),
      "./src/ln.js": () => require_ln(),
      "./src/ls.js": () => require_ls(),
      "./src/mkdir.js": () => require_mkdir(),
      "./src/mv.js": () => require_mv(),
      "./src/popd.js": () => require_popd(),
      "./src/pushd.js": () => require_pushd(),
      "./src/pwd.js": () => require_pwd(),
      "./src/rm.js": () => require_rm(),
      "./src/sed.js": () => require_sed(),
      "./src/set.js": () => require_set(),
      "./src/sort.js": () => require_sort(),
      "./src/tail.js": () => require_tail(),
      "./src/tempdir.js": () => require_tempdir(),
      "./src/test.js": () => require_test(),
      "./src/to.js": () => require_to(),
      "./src/toEnd.js": () => require_toEnd(),
      "./src/touch.js": () => require_touch(),
      "./src/uniq.js": () => require_uniq(),
      "./src/which.js": () => require_which()
    });
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/commands.js
var require_commands = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/commands.js"(exports, module) {
    init_cjs_shims();
    module.exports = [
      "cat",
      "cd",
      "chmod",
      "cp",
      "dirs",
      "echo",
      "exec",
      "find",
      "grep",
      "head",
      "ln",
      "ls",
      "mkdir",
      "mv",
      "pwd",
      "rm",
      "sed",
      "set",
      "sort",
      "tail",
      "tempdir",
      "test",
      "to",
      "toEnd",
      "touch",
      "uniq",
      "which"
    ];
  }
});

// ../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/shell.js
var require_shell = __commonJS({
  "../../node_modules/.pnpm/shelljs@0.8.5/node_modules/shelljs/shell.js"(exports) {
    init_cjs_shims();
    init_();
    var common = require_common();
    require_commands().forEach(function(command) {
      globRequire_src("./src/" + command);
    });
    exports.exit = process.exit;
    exports.error = require_error();
    exports.ShellString = common.ShellString;
    exports.env = process.env;
    exports.config = common.config;
  }
});
export default require_shell();
